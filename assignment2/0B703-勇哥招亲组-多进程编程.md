# 多进程编程

小组名称：勇哥招亲组  
小组成员：赵勇、罗颖彪、杜佳卓

- [一、实验目的](#jump1)
- [二、实验内容](#jump2)
- [三、实验过程与结果](#jump3)
- [四、实验总结](#jump4)
- [五、附实验源码](#jump5)

## <span id="jump1">一、实验目的</span>
1. 学会创建多进程程序，理解 **fork()，vfork()** 创建的子进程的特点；
2. 学会使用**有名管道**和**无名管道**实现进程间通信；
3. 学会使用**信号机制**实现进程间通信。

## <span id="jump2">二、实验内容</span>

1. 编写fork()，vfork()多进程程序，通过输出结果比较所创建的子进程的不同之处；
2. 编写fork()多进程程序，进程间模拟信号通信， 包括信号发送、捕捉与处理；
3. 编写fork()多进程程序，进程间实现有名管道和无名管道通信。具体要求如下:
    * 编写1个服务器程序server.c和2个客户端程序client1.c，client2.c，服务器和客户端之间采用FIFO管道通信；
    * 服务器和客户端各自创建自己的子进程，父进程负责完成FIFO管道通信，子进程负责输出接收到的信息， 父子进程间采用无名管道通信。

## <span id="jump3">三、实验过程与结果</span>

### 3.1 fork()和vfork()
<details>
<summary>
vfork()与fork()的区别与联系
</summary>
<br/>
简单的说，vfork()跟fork()类似，都是创建一个子进程，这两个函数的的返回值也具有相同的含义。但是vfork()创建的子进程基本上只能做一件事，那就是立即调用_exit()函数或者exec函数族成员，调用任何其它函数（包括exit()）、修改任何数据（除了保存vfork()返回值的那个变量）、执行任何其它语句（包括return）都是不应该的。此外，调用vfork()之后，父进程会一直阻塞，直到子进程调用_exit()终止，或者调用exec函数族成员。

关于如何正确使用vfork()，上面这一段就是全部了。但是为什么vfork()会这样呢？ 其实vfork()和fork()之间只有两点不同：

1. fork()会复制父进程的页表，而vfork()不会复制，直接让子进程共用父进程的页表；
2. fork()使用了写时复制技术，而vfork()没有，它任何时候都不会复制父进程地址空间。

即使算上vfork()会阻塞父进程而fork()不会，也只有三点不同，没有更多不同了。所以vfork()产生的子进程跟父进程完全共同使用同一个地址空间，甚至共享同一个函数堆栈！也就是子进程中对任何数据变量的修改，不管是局部的还是全局的，都会影响到父进程。而任何一个函数调用都会修改栈空间，这就是为什么vfork()的子进程不能随便调用别的函数。

但需要注意的是，由于vfork()毕竟还是产生一个新的进程，所以子进程拥有自己的进程描述符，拥有自己的寄存器，最重要的是，拥有自己的打开文件列表！

注意拥有自己的打开文件列表非常重要，因为如果子进程只是简单地共用父进程的打开文件列表，那么当子进程调用_exit()退出时,\_exit()内部会自动关闭当前进程打开的所有文件描述符，也就是打开文件列表里面的文件，这将导致父进程恢复执行时，无法访问到自己之前已经打开过的文件，包括标准输入、标准输出和标准错误输出。所幸的是这永远不会发生，子进程会复制父进程的打开文件列表，并增加文件引用计数。

那为什么vfork()子进程中可以调用_exit()，却不可以调用exit()，也不可以直接return呢？

exit()是对_exit()的封装，它自己在调用_exit()前会做很多清理工作，其中包括刷新并关闭当前进程使用的流缓冲（比如stdio.h里面的printf等），由于vfork()的子进程完全共享了父进程地址空间，子进程里面的流也是共享的父进程的流，所以子进程里面是不能做这些事的。

直接return就更不行了，子进程return以后，会从当前函数的外部调用点后面继续执行，这后面子进程可能将会执行很多语句，结果就没法预料了。
</details>

#### 3.1.1 fork()

```c
#include <unistd.h>
#include <stdio.h>

int main()
{
    int pid = fork();

    if (pid == -1)
        return -1;

    if (pid)
    {
        printf("I am father, my pid is %d\n", getpid());
        return 0;
    }
    else
    {
        printf("I am child, my pid is %d\n", getpid());
        return 0;
    }
}
```
结果：
![image](./image/fork.png)

#### 3.1.2 vfork()

```C
#include <stdio.h>
#include <unistd.h>

void stack1() {
    vfork();
}

void stack2() {
    _exit(0);
}

int main() {
    stack1();
    printf("%d goes 1\n", getpid());
    stack2();
    printf("%d goes 2\n", getpid());
    return 0;
}
```
父进程pid为14694，子进程pid为14695，输出结果是：

![image](./image/vfork.png)

### 3.2 模拟进程间通信
服务端
```c
#include<stdio.h>
#include<unistd.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<string.h>

int main() {
  int fd = open("./fifo1",O_RDONLY);
  int i = 0;
  char buf[24]={0};
  while(read(fd, buf, 24)>0){
    printf(buf);
  }
  close(fd);
  return 0;
}

```
客户端
```c
#include<stdio.h>
#include<unistd.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<fcntl.h>
#include<string.h>
int main() {
  char* msg = "Hello, I am client!\n";
  int fd=open("./fifo1", O_WRONLY);
  int i = 0;
  for(;i<10;i++){
    printf(msg);
    if(write(fd, msg, strlen(msg)+1)<0){
      _exit(-1);
    }
    sleep(2);
  }
  close(fd);
  return 0;
}
```
结果：
![image](./image/interprocess.png)

### 3.3 有名管道和无名管道通信


## <span id="jump4">四、实验总结</span>

### 4.1 实验收获
✅熟悉和理解了利用pipe和fifo进行进程间通信。

### 4.2 未解决问题
⚠️从fifo文件读取到的字符串与程序中定义的字符串**不相同**，因此造成对字符信息处理有误，尚未解决。
## <span id="jump5">五、附实验源码</span>
✅见code文件夹
